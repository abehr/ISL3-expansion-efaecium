import polars as pl
from pathlib import Path
from collections import defaultdict
import itertools
from pyfaidx import Fasta
import plotly.express as px

from ...data_processing import locate
from ...util import io
from ...util.gffpl import GFFPL, get_orf
from ...util.translate import translate
from ...util import efmpl
from ...figures import plot_utils as plt
'''
Rerunning the tpase diversity analysis, on E. faecium only, 
using polars and using the updated final/filtered list of Efm genomes for the manuscript.

Ultimately this is used to generate Figure 1D.
'''


# Note that this sample list was generated by code in data_processing README,
# and is the set of all NCBI & SHC E. faecium genomes. 
fp = Path('/labs/asbhatt/abehr/wf/efm/all_efm_ncbi_shc_bakta1.9_gffs')
samples = (
	pl
	.read_csv(fp / 'samples.csv')
	.filter(
		# Only use NCBI complete & SHC genomes to avoid potential issues from older nanopore chem
		pl.col('collection').str.starts_with(locate.NCBI_COMPLETE) |
		pl.col('collection').str.starts_with(locate.SHC)
	)
	.with_columns(gff=pl.format('{}/bakta/{}/bakta_proteins_htseq_compatible.gff3', pl.lit(str(fp)), 'sample'))
)

# This consists of 602 samples (493 NCBI complete; 109 SHC).
gff = GFFPL(samples).valid_cds().lf

tpase = (
	gff
	.filter(pl.col('product').str.contains('(?i)transposase')) # tpase annotations only
	.with_columns(fam=efmpl.efm_tpase_family_names_v2) # extract common Efm IS family name
	.filter(pl.col('fam').is_not_null()) # only select tpase with known family name
	.select('sample','seqid','start','end','strand','product','fam') # only the cols we need
	.collect()
)

# ===========================================================================================
# Now that we have the list of all IS family tpase annotations, extract them from each genome
# ===========================================================================================

nt_counter = itertools.count()
aa_counter = itertools.count()
all_unique_nt = defaultdict(lambda: next(nt_counter))
all_unique_aa = defaultdict(lambda: next(aa_counter))

results = []
i = 0
n = tpase.select('sample').n_unique()
for genome,group in tpase.join(samples['sample', 'genome_fp'], on='sample', how='left').group_by('genome_fp'):
	genome = Fasta(genome[0])
	for feat in group.iter_rows(named=True):
		orf = get_orf(genome, feat['seqid'], feat['start'], feat['end'], feat['strand'])
		if len(orf) < 500: continue # ignore anything that's way too short
		nt_seqid = all_unique_nt[orf]
		aa_seqid = all_unique_aa[translate(orf)]
		feat['nt_seqid'] = nt_seqid
		feat['aa_seqid'] = aa_seqid
		results.append(feat)
	
	i += 1
	io.print_progress(i, n, cadence=1)

df = pl.DataFrame(results).drop('genome_fp')


# Write information to files (v2 -- updated set of genomes for the paper)
df.write_csv('efm_tpase_per_sample_v2.csv')
with open('efm_all_unique_tpase_nt_v2.fna', 'w') as f:
	for seq,seqid in all_unique_nt.items(): f.write(f'>{seqid}\n{seq}\n')
with open('efm_all_unique_tpase_aa_v2.faa', 'w') as f:
	for seq,seqid in all_unique_aa.items(): f.write(f'>{seqid}\n{seq}\n')


# ================================================
# Finally, plot the IS tpase diversity across Efm
# ================================================

# Locally (for plotting)
fp = Path('data/efm_v2')
df = pl.read_csv(fp / 'efm_tpase_per_sample_v2.csv')

# Average tpase count per genome = 112 
df.group_by('sample').len().mean()

# Compute the stats per exact IS tpase copy
avg = (
	df
	.group_by('nt_seqid')
	.agg(
		fam=pl.col('fam').mode().first(),
		product=pl.col('product').mode().first(),
		count=pl.len()
	)
	.with_columns(avg_count=pl.col('count') / df.select('sample').n_unique())
	.with_columns(pdt=efmpl.extract_name_from_product_col())
	.sort(by='avg_count', descending=True)
)

# Make the bar plot. Note that I added IS200/IS605 to take a look but it seems like they are negligible here.
# Maybe the Bakta annotations aren't picking them up the same way as in ISEScan. 
fam_order = ['ISL3', 'IS30', 'IS256', 'IS3', 'IS6', 'IS110']
fig = px.bar(
	avg, x='avg_count', y='fam', orientation='h',
	category_orders=dict(fam=fam_order),
	hover_data='product',
	template='plotly_white',
	color_discrete_sequence=['#E4C9E1']
)

fig.update_traces(text=avg['pdt'], textposition='inside')
fig.update_traces(textfont=dict(size=10, family='Helvetica'))
fig.update_layout(uniformtext_minsize=10, uniformtext_mode='hide')
plt.common_figure_style(fig, publish=True)
fig.update_traces(marker_line_color="black", marker_line_width=0.1)


# Fix the fig dimensions to make sure the labels render how we want, and write out
fig.update_layout(height=350, width=720)
fig.write_image('Figure_1D.svg')